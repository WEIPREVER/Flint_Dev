package com.example.flint.controller;

import com.example.flint.model.Transaction;
import com.example.flint.model.enumeration.TransactionType;
import com.example.flint.repository.TransactionRepository;
import com.example.flint.service.TransactionServices;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.server.ResponseStatusException;


import javax.validation.Valid;
import java.math.BigDecimal;
import java.net.URI;
import java.net.URISyntaxException;
import java.time.Instant;
import java.time.LocalDate;
import java.time.ZoneId;
import java.util.Date;
import java.util.List;
import java.util.Optional;

//Heavily influenced by the controller generated by JHipster

@Slf4j
@RestController
@RequestMapping("/api")
public class TransactionController {
    private final TransactionServices transactionServices;

    public TransactionController(TransactionServices transactionServices) {
        this.transactionServices = transactionServices;
    }

    @PostMapping("/transactions")
    public ResponseEntity<Transaction> createTransaction(@Valid @RequestBody Transaction transaction) throws URISyntaxException {
        log.debug("Request to create transaction: {}", transaction);
        if (transaction.getId() != null) {
            throw new ResponseStatusException(HttpStatus.BAD_GATEWAY);
        }
        Transaction result = transactionServices.save(transaction);
        return ResponseEntity
                .created(new URI("/api/transactions/" + result.getId()))
                .body(result);
    }

    @GetMapping("/transactions")
    public ResponseEntity<List<Transaction>> getAllTransactions() {
        log.debug("Request to get all transactions");
        List<Transaction> listOfAllTransactions = transactionServices.findAll();
        return ResponseEntity.ok().body(listOfAllTransactions);
    }

    @GetMapping("/transactions/{id}")
    public ResponseEntity<Transaction> getTransaction(@PathVariable Long id) {
        log.debug("Request to get transaction : {}", id);
        Optional<Transaction> transaction = transactionServices.findOne(id);
        if (transaction.get() != null)
            return ResponseEntity.ok().body(transaction.get());
        else
            throw new ResponseStatusException(HttpStatus.NOT_FOUND);
    }

    //todo need to fix to use just month, day, and year

    @GetMapping("/bankAccount/{accountNumber}/transactions/findByDate")
    public ResponseEntity<List<Transaction>> getTransactionsDateOfTransaction(
            @PathVariable(value = "accountNumber") Long accountId,
            @RequestParam(value = "exact", required = false) LocalDate dateOfTransaction,
            @RequestParam(value = "start", required = false) LocalDate dateOfTransactionStart,
            @RequestParam(value = "end", required = false) LocalDate dateOfTransactionEnd) {
        log.debug("Request to get transaction by param: {}", dateOfTransaction,
                dateOfTransactionStart, dateOfTransactionEnd);
        List<Transaction> list;
        Instant dateOfTransactionStartI, dateOfTransactionEndI;
        if (dateOfTransaction != null) {
            dateOfTransactionStartI =
                    dateOfTransaction.atStartOfDay(ZoneId.systemDefault()).toInstant();
            dateOfTransactionEndI =
                    dateOfTransaction.plusDays(1).atStartOfDay(ZoneId.systemDefault()).toInstant();
        } else {
            dateOfTransactionStartI = dateOfTransactionStart.atStartOfDay(ZoneId.systemDefault()).toInstant();
            dateOfTransactionEndI = dateOfTransactionEnd.atStartOfDay(ZoneId.systemDefault()).toInstant();
        }
        list = transactionServices.findByDateOfTransactionIsBetween(
                accountId,
                dateOfTransactionStartI,
                dateOfTransactionEndI);
        log.debug(list.toString());
        return ResponseEntity.ok().body(list);
    }

    @GetMapping("/bankAccount/{accountNumber}/transactions")
    public ResponseEntity<List<Transaction>> getTransactionsByAccount(
            @PathVariable Long accountNumber,
            @RequestParam(value = "type", defaultValue = "to") String typeOfRequest) {
        List<Transaction> list;
        log.debug("Request to get transaction by param: {}", typeOfRequest,
                accountNumber);
        if (typeOfRequest.equalsIgnoreCase("to"))
            list = transactionServices.findByToAccountNumber(accountNumber);
        else
            list = transactionServices.findByFromAccountNumber(accountNumber);
        log.debug(list.toString());
        return ResponseEntity.ok().body(list);
    }

    @GetMapping("/bankAccount/{accountNumber}/transactions/findByAmount/")
    public ResponseEntity<List<Transaction>> getTransactionsByAmount(
            @PathVariable(value = "accountNumber") Long accountId,
            @RequestParam(value = "type", required = false) String typeOfRequest,
            @RequestParam(value = "start", required = false) BigDecimal transactionAmountStart,
            @RequestParam(value = "end", required = false) BigDecimal transactionAmountEnd) {
        List<Transaction> list;
        log.debug("Request to get transaction by param: {}", typeOfRequest,
                transactionAmountStart, transactionAmountEnd);
        if (typeOfRequest.equalsIgnoreCase("between") &&
                transactionAmountStart != null && transactionAmountEnd != null) {
            list = transactionServices.findByTransactionAmountIsBetween(
                    accountId,
                    transactionAmountStart,
                    transactionAmountStart);
        } else if (typeOfRequest.equalsIgnoreCase("more") && transactionAmountStart != null){
            list = transactionServices.findByTransactionAmountIsGreaterThanEqual(
                    accountId,
                    transactionAmountStart);
        }
        else if (typeOfRequest.equalsIgnoreCase("less") && transactionAmountEnd != null) {
            list = transactionServices.findByTransactionAmountLessThanEqual(
                    accountId,
                    transactionAmountStart);
        } else {
            list = transactionServices.findByTransactionAmountLessThanEqual(
                    accountId,
                    transactionAmountEnd);
        }
        log.debug(list.toString());
        return ResponseEntity.ok().body(list);
    }

    @GetMapping("/bankAccount/{accountNumber}/transactions/{typeOfTransaction}")
    public ResponseEntity<List<Transaction>> getTransactionByType(
            @PathVariable(value = "accountNumber") Long accountId,
            @PathVariable(value = "typeOfTransaction") TransactionType typeOfTransaction) {
        log.debug("Request to get transaction by param: {}", accountId,
                typeOfTransaction);
        List<Transaction> list = transactionServices.findByTypeOfTransaction(
                accountId,
                typeOfTransaction);
        log.debug(list.toString());
        return ResponseEntity.ok().body(list);
    }

    @DeleteMapping("/bankAccount/{accountNumber}/transactions/{id}")
    public ResponseEntity<Void> deleteTransaction(
            @PathVariable Long id) {
        log.debug("Request to delete: {}", id);
        transactionServices.delete(id);
        return ResponseEntity
                .noContent()
                .build();
    }

    @GetMapping("/bankAccount/{accountNumber}/transactions/findByCategory")
    public ResponseEntity<List<Transaction>> getTransactionByCategory_Id(
            @PathVariable(value = "accountNumber") Long accountId,
            @RequestParam (value = "category") Long id) {
        log.debug("Request to get transaction by param: {}", accountId, id);
        List<Transaction> list = transactionServices.findByCategory_Id(
                accountId,
                id);
        log.debug(list.toString());
        return ResponseEntity.ok().body(list);
    }

    // todo: need to do update and partial update if needed

}
